.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH readonly 3pm "perl 5.004, patch 04" "21/May/100" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
readonly \- Perl pragma and function module to create readonly scalars 
.SH "SYNOPSIS"
.PP
.Vb 1
\&    ##### Compile time -- create, assign & set readonly in one step
.Ve
.Vb 6
\&    use readonly 
\&            '$MAX_LINES' => 70,
\&            '$TOPIC'     => 'computing',
\&            '$TRUE'      => 1,
\&            '$FALSE'     => 0,
\&            '$PI'        => 4 * atan2( 1, 1 ),
.Ve
.Vb 6
\&            '$ALPHA'     => 1.761,
\&            '$BETA'      => 2.814,
\&            '$GAMMA'     => 4.012,
\&            '$PATH'      => '/usr/local/lib/project/include',
\&            '$EXE'       => '/usr/local/bin/project',
\&            ;
.Ve
.Vb 2
\&    # Have to use a separate readonly if we refer back.
\&    use readonly '$RC'  => "$EXE/config" ;
.Ve
.Vb 1
\&    $RC = '/new/path' ; # eval trappable error
.Ve
.Vb 1
\&    ##### Run time -- set readonly
.Ve
.Vb 1
\&    use readonly () ; # If no previous pragma calls.
.Ve
.Vb 1
\&    use vars qw( $BACKGROUND $FOREGROUND $HIGHLIGHT ) ; # Predeclare.
.Ve
.Vb 3
\&    $BACKGROUND = param( 'green' ) ;    # Pre-assign
\&    $FOREGROUND = param( 'blue' ) ;
\&    $HIGHLIGHT  = param( 'yellow' ) ;
.Ve
.Vb 1
\&    readonly->set( '$BACKGROUND', '$FOREGROUND', '$HIGHLIGHT' ) ;
.Ve
.Vb 1
\&    $BACKGROUND = 'red' ; # eval trappable error
.Ve
.SH "DESCRIPTION"
The readonly module can be used either as a compile-time pragma or a run-time
class module.
.PP
When used as a pragma it creates readonly scalars in the current namespace.
When used as a function module it marks scalars as readonly. Only package
scalars may be made readonly, \fInot\fR \f(CWmy\fR scalars. \f(CWreadonly\fR scalars may be
used in all contexts where read/write scalars would be used with the exception
that you will get an \f(CWeval\fR trappable run-time error \*(L"Modification of a
read-only value attempted...\*(R" if you try to assign to a readonly scalar.
.PP
The pragma, \f(CWconstant\fR, provides apparently similar functionality (and more,
since \f(CWconstant\fR also handles arrays, hashes etc). However \f(CWconstant\fRs are
\fInot\fR readonly scalars, but rather subroutines which behave like them and
which must be used with different syntaxes in different contexts. \f(CWreadonly\fRs
can be used with the same consistent scalar syntax throughout. Also
\f(CWreadonly\fRs may be set either at compile-time \fIor\fR at run-time.
.Sh "String Interpolation"
.PP
.Vb 2
\&    use readonly '$PI' => 4 * atan2 1, 1 ; # Compile time
\&    use constant PI    => 4 * atan2 1, 1 ; # Compile time
.Ve
We can print \f(CWreadonly\fRs directly:
.PP
.Vb 1
\&    print "The value of pi is $PI\en" ;
.Ve
but for \f(CWconstant\fRs we must do this:
.PP
.Vb 3
\&    print "The value of pi is ", PI, "\en" ;
\&    
\&or this:
.Ve
.Vb 1
\&    print "The value of pi is @{[PI]}\en" ;
.Ve
.Sh "Hash Keys"
.PP
.Vb 2
\&    use readonly '$TOPIC' => 'geology' ;
\&    use constant TOPIC    => 'geology' ;
.Ve
.Vb 5
\&    my %topic = (
\&            geology   => 5,
\&            computing => 7,
\&            biology   => 9,
\&        ) ;
.Ve
Using a \f(CWreadonly\fR scalar we can simply write:
.PP
.Vb 1
\&    my $value = $topic{$TOPIC}
.Ve
however, if we try to access one of the hash elements using the \f(CWconstant\fR:
.PP
.Vb 1
\&    my $value = $topic{TOPIC} ;
.Ve
we get an unwelcome surprise: \f(CW$value\fR is set to \f(CWundef\fR because perl will
take \s-1TOPIC\s0 to be the literal string \*(L'\s-1TOPIC\s0\*(R' and since no hash element has that
key the result is undef. Thus in this situation we would have to write:
.PP
.Vb 1
\&    my $value = $topic{TOPIC()} ;
.Ve
or perhaps:
.PP
.Vb 1
\&    my $value = $topic{&TOPIC} ;
.Ve
.Sh "Runtime readonly's"
Sometimes we only know what the readonly value will be after performing some
of our execution; in such cases we can use \f(CWreadonly->set\fR to make an
existing scalar readonly: 
.PP
.Vb 2
\&    use readonly () ; # If not already use'd
\&    use vars qw( $RED $GREEN $BLUE $YELLOW ) ; # Predeclare
.Ve
.Vb 4
\&    $RED    = '#FF0000' ; # Pre-assign
\&    $GREEN  = '#00FF00' ;
\&    $BLUE   = '#0000FF' ;
\&    $YELLOW = '#FFFF00' ;
.Ve
.Vb 1
\&    readonly->set( '$RED', '$GREEN', '$BLUE', '$YELLOW ) ;
.Ve
.SH "BUGS"
Only copes with scalars.
.PP
In some tests with 5.004 \f(CWreadonly->set\fR gives spurious warnings.
.PP
Sometimes with 5.004 when using eval exception handling you get \*(L"Use of
uninitialized value at...\*(R" errors; the cure is to write:
.PP
.Vb 3
\&    eval {
\&        $@ = undef ;
\&        # rest as normal
.Ve
.SH "AUTHOR"
Mark Summerfield. I can be contacted as <summer@perlpress.com> \-
please include the word \*(L'readonly\*(R' in the subject line.
.PP
I copied some ideas from \f(CWconstant.pm\fR.
.SH "COPYRIGHT"
Copyright (c) Mark Summerfield 2000. All Rights Reserved.
.PP
This module may be used/distributed/modified under the same terms as perl
itself. 
.SH "SEE ALSO"
Constant or readonly scalars, arrays and hashes are available through other
mechanisms:
.Ip "\(bu" 4
Tom Phoenix's standard module \f(CWconstant\fR. This has the cons described above,
but the pros that it can provide readonly arrays and may be faster than other
approaches because the perl compiler cooperates with it behind the scenes.
.Ip "\(bu" 4
Graham Barr's tie-based code archived at
http://www.xray.mpe.mpg.de/mailing-lists/modules/1999-02/msg00090.html
.Ip "\(bu" 4
Mark-Jason Dominus\*(R' tie-based code at http://www.plover.com/~mjd/perl/Locked/
.Ip "\(bu" 4
My own tie-based code at http://www.perlpress.com/perl/antiques.html
Tie::Const.
.PP
Tie-based implementations should be able to offer readonly scalars, arrays and
hashes, but these implementations are likely to have a performance overhead
compared with \f(CWreadonly\fR or \f(CWconstant\fR.

.rn }` ''
.IX Title "readonly 3pm"
.IX Name "readonly - Perl pragma and function module to create readonly scalars"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "String Interpolation"

.IX Subsection "Hash Keys"

.IX Subsection "Runtime readonly's"

.IX Header "BUGS"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

.IX Header "SEE ALSO"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

